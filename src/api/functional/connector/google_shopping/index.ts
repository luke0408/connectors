/**
 * @packageDocumentation
 * @module api.functional.connector.google_shopping
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection, Primitive, Resolved } from "@nestia/fetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import type { IGoogleShopping } from "../../../structures/connector/google_shopping/IGoogleShopping";

export * as twenty_nine_centimeter from "./twenty_nine_centimeter";
export * as eql from "./eql";
export * as market_kurly from "./market_kurly";
export * as ali_express from "./ali_express";
export * as olive_young from "./olive_young";
export * as yes_twenty_four from "./yes_twenty_four";

/**
 * 상품을 무신사에서 검색합니다.
 *
 * @param input 검색 조건
 * @summary 무신사 검색
 * @returns 검색 결과
 *
 * @controller GoogleShoppingController.musinsa
 * @path POST /connector/google-shopping/musinsa
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function musinsa(
  connection: IConnection,
  input: musinsa.Input,
): Promise<musinsa.Output> {
  return !!connection.simulate
    ? musinsa.simulate(connection, input)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...musinsa.METADATA,
          template: musinsa.METADATA.path,
          path: musinsa.path(),
        },
        input,
      );
}
export namespace musinsa {
  export type Input = Primitive<IGoogleShopping.IRequestStandAlone>;
  export type Output = Primitive<Array<IGoogleShopping.IResponse>>;

  export const METADATA = {
    method: "POST",
    path: "/connector/google-shopping/musinsa",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = () => "/connector/google-shopping/musinsa";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): Resolved<Primitive<Array<IGoogleShopping.IResponse>>> =>
    typia.random<Primitive<Array<IGoogleShopping.IResponse>>>(g);
  export const simulate = (
    connection: IConnection,
    input: musinsa.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(input));
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * 상품을 OCO에서 검색합니다.
 *
 * @param input 검색 조건
 * @summary OCO 검색
 * @returns 검색 결과
 *
 * @controller GoogleShoppingController.oco
 * @path POST /connector/google-shopping/oco
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function oco(
  connection: IConnection,
  input: oco.Input,
): Promise<oco.Output> {
  return !!connection.simulate
    ? oco.simulate(connection, input)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...oco.METADATA,
          template: oco.METADATA.path,
          path: oco.path(),
        },
        input,
      );
}
export namespace oco {
  export type Input = Primitive<IGoogleShopping.IRequestStandAlone>;
  export type Output = Primitive<Array<IGoogleShopping.IResponse>>;

  export const METADATA = {
    method: "POST",
    path: "/connector/google-shopping/oco",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = () => "/connector/google-shopping/oco";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): Resolved<Primitive<Array<IGoogleShopping.IResponse>>> =>
    typia.random<Primitive<Array<IGoogleShopping.IResponse>>>(g);
  export const simulate = (
    connection: IConnection,
    input: oco.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(input));
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * 상품을 유니클로에서 검색합니다.
 *
 * @param input 검색 조건
 * @summary 유니클로 검색
 * @returns 검색 결과
 *
 * @controller GoogleShoppingController.uniqlo
 * @path POST /connector/google-shopping/uniqlo
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function uniqlo(
  connection: IConnection,
  input: uniqlo.Input,
): Promise<uniqlo.Output> {
  return !!connection.simulate
    ? uniqlo.simulate(connection, input)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...uniqlo.METADATA,
          template: uniqlo.METADATA.path,
          path: uniqlo.path(),
        },
        input,
      );
}
export namespace uniqlo {
  export type Input = Primitive<IGoogleShopping.IRequestStandAlone>;
  export type Output = Primitive<Array<IGoogleShopping.IResponse>>;

  export const METADATA = {
    method: "POST",
    path: "/connector/google-shopping/uniqlo",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = () => "/connector/google-shopping/uniqlo";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): Resolved<Primitive<Array<IGoogleShopping.IResponse>>> =>
    typia.random<Primitive<Array<IGoogleShopping.IResponse>>>(g);
  export const simulate = (
    connection: IConnection,
    input: uniqlo.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(input));
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * 상품을 쿠팡에서 검색합니다.
 *
 * @param input 검색 조건
 * @summary 쿠팡 검색
 * @returns 검색 결과
 *
 * @controller GoogleShoppingController.coupang
 * @path POST /connector/google-shopping/coupang
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function coupang(
  connection: IConnection,
  input: coupang.Input,
): Promise<coupang.Output> {
  return !!connection.simulate
    ? coupang.simulate(connection, input)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...coupang.METADATA,
          template: coupang.METADATA.path,
          path: coupang.path(),
        },
        input,
      );
}
export namespace coupang {
  export type Input = Primitive<IGoogleShopping.IRequestStandAlone>;
  export type Output = Primitive<Array<IGoogleShopping.IResponse>>;

  export const METADATA = {
    method: "POST",
    path: "/connector/google-shopping/coupang",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = () => "/connector/google-shopping/coupang";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): Resolved<Primitive<Array<IGoogleShopping.IResponse>>> =>
    typia.random<Primitive<Array<IGoogleShopping.IResponse>>>(g);
  export const simulate = (
    connection: IConnection,
    input: coupang.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(input));
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * 상품을 아이허브에서 검색합니다.
 *
 * @param input 검색 조건
 * @summary 아이허브 검색
 * @returns 검색 결과
 *
 * @controller GoogleShoppingController.iherb
 * @path POST /connector/google-shopping/iherb
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function iherb(
  connection: IConnection,
  input: iherb.Input,
): Promise<iherb.Output> {
  return !!connection.simulate
    ? iherb.simulate(connection, input)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...iherb.METADATA,
          template: iherb.METADATA.path,
          path: iherb.path(),
        },
        input,
      );
}
export namespace iherb {
  export type Input = Primitive<IGoogleShopping.IRequestStandAlone>;
  export type Output = Primitive<Array<IGoogleShopping.IResponse>>;

  export const METADATA = {
    method: "POST",
    path: "/connector/google-shopping/iherb",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = () => "/connector/google-shopping/iherb";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): Resolved<Primitive<Array<IGoogleShopping.IResponse>>> =>
    typia.random<Primitive<Array<IGoogleShopping.IResponse>>>(g);
  export const simulate = (
    connection: IConnection,
    input: iherb.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(input));
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * 상품을 알라딘에서 검색합니다.
 *
 * @param input 검색 조건
 * @summary 알라딘 검색
 * @returns 검색 결과
 *
 * @controller GoogleShoppingController.aladine
 * @path POST /connector/google-shopping/aladine
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function aladine(
  connection: IConnection,
  input: aladine.Input,
): Promise<aladine.Output> {
  return !!connection.simulate
    ? aladine.simulate(connection, input)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...aladine.METADATA,
          template: aladine.METADATA.path,
          path: aladine.path(),
        },
        input,
      );
}
export namespace aladine {
  export type Input = Primitive<IGoogleShopping.IRequestStandAlone>;
  export type Output = Primitive<Array<IGoogleShopping.IResponse>>;

  export const METADATA = {
    method: "POST",
    path: "/connector/google-shopping/aladine",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: null,
  } as const;

  export const path = () => "/connector/google-shopping/aladine";
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): Resolved<Primitive<Array<IGoogleShopping.IResponse>>> =>
    typia.random<Primitive<Array<IGoogleShopping.IResponse>>>(g);
  export const simulate = (
    connection: IConnection,
    input: aladine.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(input));
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
